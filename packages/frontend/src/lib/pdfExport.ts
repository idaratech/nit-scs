import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

// NIT brand colors
const PRIMARY_BLUE = '#1e3a5f';
const SECONDARY_GOLD = '#c5a572';
const LIGHT_GRAY = '#f5f5f5';

export interface PdfOptions {
  title: string;
  subtitle?: string;
  date?: Date;
  documentNumber?: string;
  orientation?: 'portrait' | 'landscape';
}

export interface TableColumn {
  header: string;
  dataKey: string;
  width?: number;
}

/**
 * Create a new jsPDF instance with NIT letterhead.
 * Top: "NIT Supply Chain Management" (blue, 16pt), document title below (14pt)
 * Right-aligned: Date, Document Number
 * Footer added via didDrawPage hook: Page X of Y, "Generated by NIT SCS V2"
 */
export function createNitPdf(options: PdfOptions): jsPDF {
  const { title, subtitle, date = new Date(), documentNumber, orientation = 'portrait' } = options;

  const doc = new jsPDF({ orientation, unit: 'mm', format: 'a4' });
  const pageWidth = doc.internal.pageSize.getWidth();

  // --- Header ---
  // Company name
  doc.setFontSize(16);
  doc.setTextColor(PRIMARY_BLUE);
  doc.setFont('helvetica', 'bold');
  doc.text('NIT Supply Chain Management', 14, 18);

  // Document title
  doc.setFontSize(14);
  doc.setTextColor(SECONDARY_GOLD);
  doc.text(title, 14, 26);

  // Subtitle
  if (subtitle) {
    doc.setFontSize(10);
    doc.setTextColor('#666666');
    doc.setFont('helvetica', 'normal');
    doc.text(subtitle, 14, 32);
  }

  // Right-aligned: date + document number
  doc.setFontSize(9);
  doc.setTextColor('#444444');
  doc.setFont('helvetica', 'normal');
  const dateStr = date.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' });
  doc.text(`Date: ${dateStr}`, pageWidth - 14, 18, { align: 'right' });
  if (documentNumber) {
    doc.text(`Doc #: ${documentNumber}`, pageWidth - 14, 24, { align: 'right' });
  }

  // Separator line
  const lineY = subtitle ? 36 : 30;
  doc.setDrawColor(PRIMARY_BLUE);
  doc.setLineWidth(0.5);
  doc.line(14, lineY, pageWidth - 14, lineY);

  // Footer hook: runs on every page
  const totalPagesPlaceholder = '{total_pages_count_string}';
  doc.setFont('helvetica', 'normal');

  // We use the internal event system via autoTable's didDrawPage
  // but also set up a final page count replacement
  const pageCount = doc.getNumberOfPages;
  // Store reference for the finalize step
  (doc as unknown as Record<string, unknown>).__nitStartY = lineY + 6;
  (doc as unknown as Record<string, unknown>).__nitTotalPlaceholder = totalPagesPlaceholder;

  return doc;
}

/**
 * Get the current Y position to start content after the header.
 */
export function getStartY(doc: jsPDF): number {
  return ((doc as unknown as Record<string, unknown>).__nitStartY as number) ?? 40;
}

/**
 * Add a data table to the PDF using jspdf-autotable.
 * Returns the final Y position after the table.
 */
export function addTable(doc: jsPDF, columns: TableColumn[], data: Record<string, unknown>[], startY?: number): number {
  const y = startY ?? getStartY(doc);

  autoTable(doc, {
    startY: y,
    head: [columns.map(c => c.header)],
    body: data.map(row => columns.map(c => String(row[c.dataKey] ?? ''))),
    headStyles: {
      fillColor: PRIMARY_BLUE,
      textColor: '#ffffff',
      fontStyle: 'bold',
      fontSize: 8,
      halign: 'left',
    },
    bodyStyles: {
      fontSize: 8,
      textColor: '#333333',
      cellPadding: 2,
    },
    alternateRowStyles: {
      fillColor: LIGHT_GRAY,
    },
    columnStyles: columns.reduce(
      (acc, col, idx) => {
        if (col.width) {
          acc[idx] = { cellWidth: col.width };
        }
        return acc;
      },
      {} as Record<number, { cellWidth: number }>,
    ),
    margin: { left: 14, right: 14 },
    didDrawPage: hookData => {
      addPageFooter(doc);
    },
  });

  const lastTable = (doc as unknown as Record<string, unknown>).lastAutoTable as { finalY: number } | undefined;
  return lastTable?.finalY ?? y + 10;
}

/**
 * Add a key-value info section (like document header fields).
 * Returns the Y position after the section.
 */
export function addInfoSection(doc: jsPDF, fields: Array<{ label: string; value: string }>, startY: number): number {
  let y = startY;
  const leftCol = 14;
  const valueCol = 60;
  const lineHeight = 6;

  for (const field of fields) {
    doc.setFontSize(9);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(PRIMARY_BLUE);
    doc.text(`${field.label}:`, leftCol, y);

    doc.setFont('helvetica', 'normal');
    doc.setTextColor('#333333');
    doc.text(field.value, valueCol, y);

    y += lineHeight;
  }

  return y + 2;
}

/**
 * Add page footer with page numbers and generation note.
 */
function addPageFooter(doc: jsPDF): void {
  const pageHeight = doc.internal.pageSize.getHeight();
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageNumber = doc.getCurrentPageInfo().pageNumber;

  doc.setFontSize(7);
  doc.setTextColor('#999999');
  doc.setFont('helvetica', 'normal');

  // Left: generation note
  doc.text('Generated by NIT SCS V2', 14, pageHeight - 8);

  // Right: page number
  doc.text(`Page ${pageNumber}`, pageWidth - 14, pageHeight - 8, { align: 'right' });

  // Subtle line above footer
  doc.setDrawColor('#cccccc');
  doc.setLineWidth(0.2);
  doc.line(14, pageHeight - 12, pageWidth - 14, pageHeight - 12);
}

/**
 * Trigger browser download of the PDF.
 */
export function downloadPdf(doc: jsPDF, filename: string): void {
  // Add footers to all pages before saving
  const totalPages = doc.getNumberOfPages();
  for (let i = 1; i <= totalPages; i++) {
    doc.setPage(i);
    addPageFooter(doc);
  }
  doc.save(filename.endsWith('.pdf') ? filename : `${filename}.pdf`);
}

// ---------------------------------------------------------------------------
// Document-specific PDF generators
// ---------------------------------------------------------------------------

export interface GrnLineItem {
  itemCode: string;
  itemName: string;
  unit: string;
  quantity: number;
  unitPrice: number;
  totalPrice: number;
  condition?: string;
}

export interface GrnData {
  documentNumber: string;
  supplier: string;
  warehouse: string;
  receivedDate: string;
  poNumber?: string;
  status: string;
  items: GrnLineItem[];
  notes?: string;
}

export function generateGrnPdf(grn: GrnData): void {
  const doc = createNitPdf({
    title: 'Goods Receipt Note (GRN)',
    documentNumber: grn.documentNumber,
    subtitle: `Supplier: ${grn.supplier}`,
  });

  let y = addInfoSection(
    doc,
    [
      { label: 'Document #', value: grn.documentNumber },
      { label: 'Supplier', value: grn.supplier },
      { label: 'Warehouse', value: grn.warehouse },
      { label: 'Received Date', value: grn.receivedDate },
      { label: 'PO Number', value: grn.poNumber ?? 'N/A' },
      { label: 'Status', value: grn.status },
    ],
    getStartY(doc),
  );

  y = addTable(
    doc,
    [
      { header: '#', dataKey: '_index', width: 10 },
      { header: 'Code', dataKey: 'itemCode', width: 30 },
      { header: 'Description', dataKey: 'itemName' },
      { header: 'Unit', dataKey: 'unit', width: 15 },
      { header: 'Qty', dataKey: 'quantity', width: 15 },
      { header: 'Price', dataKey: 'unitPrice', width: 20 },
      { header: 'Total', dataKey: 'totalPrice', width: 25 },
      { header: 'Condition', dataKey: 'condition', width: 20 },
    ],
    grn.items.map((item, i) => ({
      ...item,
      _index: String(i + 1),
      unitPrice: item.unitPrice.toLocaleString(),
      totalPrice: item.totalPrice.toLocaleString(),
      condition: item.condition ?? 'New',
    })),
    y + 4,
  );

  // Grand total
  const grandTotal = grn.items.reduce((s, i) => s + i.totalPrice, 0);
  doc.setFontSize(10);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(PRIMARY_BLUE);
  doc.text(`Grand Total: ${grandTotal.toLocaleString()} SAR`, doc.internal.pageSize.getWidth() - 14, y + 8, {
    align: 'right',
  });

  if (grn.notes) {
    doc.setFontSize(8);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor('#666666');
    doc.text(`Notes: ${grn.notes}`, 14, y + 16);
  }

  downloadPdf(doc, `GRN_${grn.documentNumber}_${new Date().toISOString().slice(0, 10)}`);
}

export interface MiData {
  documentNumber: string;
  project: string;
  requester: string;
  issuedDate: string;
  warehouse: string;
  status: string;
  items: GrnLineItem[];
  notes?: string;
}

export function generateMiPdf(mi: MiData): void {
  const doc = createNitPdf({
    title: 'Material Issuance (MI)',
    documentNumber: mi.documentNumber,
    subtitle: `Project: ${mi.project}`,
  });

  let y = addInfoSection(
    doc,
    [
      { label: 'Document #', value: mi.documentNumber },
      { label: 'Project', value: mi.project },
      { label: 'Requester', value: mi.requester },
      { label: 'Issued Date', value: mi.issuedDate },
      { label: 'Warehouse', value: mi.warehouse },
      { label: 'Status', value: mi.status },
    ],
    getStartY(doc),
  );

  y = addTable(
    doc,
    [
      { header: '#', dataKey: '_index', width: 10 },
      { header: 'Code', dataKey: 'itemCode', width: 30 },
      { header: 'Description', dataKey: 'itemName' },
      { header: 'Unit', dataKey: 'unit', width: 15 },
      { header: 'Qty', dataKey: 'quantity', width: 15 },
      { header: 'Price', dataKey: 'unitPrice', width: 20 },
      { header: 'Total', dataKey: 'totalPrice', width: 25 },
    ],
    mi.items.map((item, i) => ({
      ...item,
      _index: String(i + 1),
      unitPrice: item.unitPrice.toLocaleString(),
      totalPrice: item.totalPrice.toLocaleString(),
    })),
    y + 4,
  );

  const grandTotal = mi.items.reduce((s, i) => s + i.totalPrice, 0);
  doc.setFontSize(10);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(PRIMARY_BLUE);
  doc.text(`Grand Total: ${grandTotal.toLocaleString()} SAR`, doc.internal.pageSize.getWidth() - 14, y + 8, {
    align: 'right',
  });

  downloadPdf(doc, `MI_${mi.documentNumber}_${new Date().toISOString().slice(0, 10)}`);
}

export interface GatePassData {
  documentNumber: string;
  type: string;
  date: string;
  warehouse: string;
  vehiclePlate: string;
  driverName: string;
  driverIdNumber?: string;
  linkedDocument?: string;
  status: string;
  notes?: string;
}

export function generateGatePassPdf(gatePass: GatePassData): void {
  const doc = createNitPdf({
    title: 'Gate Pass',
    documentNumber: gatePass.documentNumber,
    subtitle: `Type: ${gatePass.type}`,
  });

  let y = addInfoSection(
    doc,
    [
      { label: 'Document #', value: gatePass.documentNumber },
      { label: 'Type', value: gatePass.type },
      { label: 'Date', value: gatePass.date },
      { label: 'Warehouse', value: gatePass.warehouse },
      { label: 'Vehicle Plate', value: gatePass.vehiclePlate },
      { label: 'Driver Name', value: gatePass.driverName },
      { label: 'Driver ID', value: gatePass.driverIdNumber ?? 'N/A' },
      { label: 'Linked Document', value: gatePass.linkedDocument ?? 'None' },
      { label: 'Status', value: gatePass.status },
    ],
    getStartY(doc),
  );

  if (gatePass.notes) {
    doc.setFontSize(9);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor('#666666');
    doc.text(`Notes: ${gatePass.notes}`, 14, y + 4);
    y += 10;
  }

  // Signature line
  y += 16;
  doc.setDrawColor('#333333');
  doc.setLineWidth(0.3);
  doc.line(14, y, 80, y);
  doc.line(110, y, 196, y);

  doc.setFontSize(8);
  doc.setTextColor('#666666');
  doc.text('Security Guard Signature', 14, y + 5);
  doc.text('Authorized By', 110, y + 5);

  downloadPdf(doc, `GatePass_${gatePass.documentNumber}_${new Date().toISOString().slice(0, 10)}`);
}

export interface JobOrderData {
  documentNumber: string;
  project: string;
  requester: string;
  requestDate: string;
  joType: string;
  priority: string;
  driverName?: string;
  vehiclePlate?: string;
  status: string;
  notes?: string;
}

export function generateJobOrderPdf(jobOrder: JobOrderData): void {
  const doc = createNitPdf({
    title: 'Job Order',
    documentNumber: jobOrder.documentNumber,
    subtitle: `Type: ${jobOrder.joType} | Priority: ${jobOrder.priority}`,
  });

  const y = addInfoSection(
    doc,
    [
      { label: 'Document #', value: jobOrder.documentNumber },
      { label: 'Project', value: jobOrder.project },
      { label: 'Requester', value: jobOrder.requester },
      { label: 'Request Date', value: jobOrder.requestDate },
      { label: 'Type', value: jobOrder.joType },
      { label: 'Priority', value: jobOrder.priority },
      { label: 'Driver', value: jobOrder.driverName ?? 'N/A' },
      { label: 'Vehicle Plate', value: jobOrder.vehiclePlate ?? 'N/A' },
      { label: 'Status', value: jobOrder.status },
    ],
    getStartY(doc),
  );

  if (jobOrder.notes) {
    doc.setFontSize(9);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor('#666666');
    doc.text(`Notes: ${jobOrder.notes}`, 14, y + 4);
  }

  downloadPdf(doc, `JO_${jobOrder.documentNumber}_${new Date().toISOString().slice(0, 10)}`);
}

export interface InventoryItem {
  sn: number;
  project: string;
  itemCode: string;
  description: string;
  size: string;
  unit: string;
  location: string;
  subLocation: string;
  balance: number;
}

export function generateInventoryReportPdf(items: InventoryItem[], warehouseName: string): void {
  const doc = createNitPdf({
    title: 'Inventory Report',
    subtitle: `Warehouse: ${warehouseName}`,
    orientation: items.length > 0 ? 'landscape' : 'portrait',
  });

  const totalBalance = items.reduce((s, i) => s + i.balance, 0);

  const y = addInfoSection(
    doc,
    [
      { label: 'Warehouse', value: warehouseName },
      { label: 'Total Items', value: String(items.length) },
      { label: 'Total Balance', value: totalBalance.toLocaleString() },
      {
        label: 'Report Date',
        value: new Date().toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' }),
      },
    ],
    getStartY(doc),
  );

  addTable(
    doc,
    [
      { header: '#', dataKey: 'sn', width: 10 },
      { header: 'Project', dataKey: 'project', width: 35 },
      { header: 'Code', dataKey: 'itemCode', width: 40 },
      { header: 'Description', dataKey: 'description' },
      { header: 'Size', dataKey: 'size', width: 25 },
      { header: 'Unit', dataKey: 'unit', width: 12 },
      { header: 'Location', dataKey: 'locationFull', width: 30 },
      { header: 'Balance', dataKey: 'balance', width: 20 },
    ],
    items.map(item => ({
      ...item,
      locationFull: `${item.location} - ${item.subLocation}`,
      balance: item.balance.toLocaleString(),
    })),
    y + 4,
  );

  downloadPdf(doc, `Inventory_${warehouseName.replace(/\s+/g, '_')}_${new Date().toISOString().slice(0, 10)}`);
}
